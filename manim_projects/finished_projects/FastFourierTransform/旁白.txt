<!-- part1 -->
Hello,大家好
这一期视频我来讲解一下快速傅里叶变换
由于这一期视频的内容比较多 而且并不适合全部观看
所以我选择了将这期视频做成了互动视频
以便观众根据需要选择观看的方式
观看本视频最短路径需要   min 最长需要   min
由于这是我第一次做这样的视频 经验还不够
所以看完后不妨在评论区留下些反馈吧

<!-- part2 -->
那么首先 我们来看一下学习快速傅里叶变换算法需要哪些前置知识
FFT的核心算法是基于复数和单位根的
所以 我们当然需要先了解复数的相关运算法则
而且需要了解单位根的一些独特性质
来学习快速傅里叶变换背后的原理
最后 在算法竞赛中 FFT的最普遍应用是求多项式乘法 或者说卷积
所以 如果需要学习用FFT求多项式乘法的话 也需要有多项式的相关知识
那么现在 做出你的选择吧


<!-- part3 -->
形如z=a+bi的数被称为复数
其中a、b为实数 i为根号-1 称为虚数单位
就如同1为实数单位一样
在复数中 a被称为实部 b被称为虚部
复数的加法运算也十分简单
只要将i看做一个字母 对原式运用分配律结合律 就能得到最后的法则
即结果的实部为两加数实部的和
结果的虚部为两加数虚部的和
如果是进行减法的话 只需将黄色符号变成减号即可
对于两复数的乘法也是同理 将i看作字母
将原式拆开 再根据i等于根号-1 i方等于-1 进行化简就能得到结果
对于除法 FFT中并没有涉及 但这里还是简要地给出
其主要思想是分数上下同乘分母的共轭复数 即c-di
使分母变为实数 再进行化简 这里直接给出公式
对于复数 还有一个很重要的定理 即欧拉定理
它可以将一个负数表示成e指数的形式 方便运算
所以一个负数也可以写成 r乘e的iθ次方
其中r为它的模 θ为它的辐角

<!-- part4 -->
任意一个复数a+bi对应了复平面上的一个点（a，b）
其横坐标为实部 纵坐标为虚部
通过复平面我们可以更好地理解复数
前面我们所说的模 即为它在复平面上对应的点到原点的距离
辐角即为它在复平面上对应的点到原点连线与x轴的夹角
知道了复数的运算法则 我们就能用代码来实现它了


<!-- part5 -->
FFT的核心是用单位根的某些独特性质来快速实现的
我们知道 每个复数都可以表示为模乘以e的(i辐角)次方
所以两个复数相乘的结果即为 两复数模相乘再乘以e的(i辐角的和)次方
而单位根 是方程z^n=1在复数范围内的n个根
因为单位根的n次方为1 所以单位根的模一定为1
因此单位根乘其自身就相当于辐角加一倍
由于每个单位根的n次方都落在复平面上(1,0)这个点
所以每个单位根的辐角的n倍都是2π的倍数
那我们就可以轻松地找到这些点
并使用欧拉定理 将其写成实部加i乘虚部的形式
我们也可以发现 单位根都均匀地落在单位圆上
每个单位根都可以看成 这个 单位根的幂
所以我们将这个根称为主n次单位根 记为w_n

<!-- part6 -->
下面我们来探寻一下单位根的三个重要引理
首先是消去引理 即w_{dn}^{dk}=w_n^k
我们用定义可以轻松地推出这个结论
在复平面上 我们可以更简单地理解这个结论
在图上可以看出 主dn次单位根的dk次幂
恰好与主n次单位根的k次幂相重合
第二个是折半引理 也是FFT的核心
同理 我们先用计算来推出这个结论
然后在复平面上 我们以8次单位根为例
将主8次单位根平方 即辐角加倍
再将主8次单位根的(1+4)次幂平方
也可以发现 这两个点重合了
同时 这两个点也和主4次单位根重合
这也就用复平面解释了这个引理
第三个是求和引理 将在逆FFT中用到
我们将任意一个单位根求其几何级数
根据等比数列求和公式 就可以计算出
这个值恒等于0


<!-- part7 -->
在算法竞赛中FFT经常用来处理多项式乘法的内容
那么我们现在来了解一下关于多项式的前置知识
首先多项式是指由未知数和系数通过有限次加减法
乘法以及自然数幂次的乘方运算得到的代数表达式
如下F(x)就是一个n次多项式
在算法竞赛中 经常处理的就是这样的一元多项式
对于这个多项式 我们还可以用Σ来简单表示
其中多项式的次数 就是最高次的次数
记为degree(F)=n
多项式的次数界 指任何一个严格大于多项式次数的整数
由于FFT只能处理2的幂次的长度 所以要引入次数界的概念来将多项式扩展次数
下面我们来看多项式的运算法则
首先多项式的加法
现有两个多项式A(x)和B(x) 将其相加
可以将AB中x的次数相等的两项加在一起
最后就得到了结果的多项式C(x)
当然 我们可以用∑来简写
其中的系数c_i 即为对应相等x次数的项的系数之和a_i加b_i

<!-- part8 -->
再来看一下多项式的乘法
我们先以一个具体的例子为例
将这两个多项式相乘 可以用第二个多项式的每一项
乘以第一个多项式 得到三个多项式
再对三个多项式进行加法运算 得到最终的结果
通过结果可以发现 结果的次数为两多项式次数的和
再推广到两同次多项式相乘的情况 给出两个n次多项式AB求其乘积C
根据刚刚的结论 可以知道结果的次数为2n
它的系数根据前面的计算方法可以稍加演算推导出来
而这个系数向量c又被称为向量ab的卷积
再一般的情况为了计算简便
可以将两个多项式的次数用添加0系数的方法升至次数界中的同一次数n
那么其乘积也是次数为2n的多项式

<!-- part9 -->
多项式有两种表示方法
第一种是系数表示 也是平时最常用最直观的表示方法
它将一个多项式表示成由其系数构成的向量的形式
用系数表示进行运算时 
加法直接将对应项相加 时间复杂度O(n)
乘法则计算两多项式系数向量的卷积 复杂度O(n^2)
已知系数 给出一个x值并求A(x)的过程叫求值
可以直接使用霍纳法则即秦九韶算法 复杂度O(n)
第二种表示方法是点值表示 即用至少n个多项式上的点来表示
使用点值表示进行运算时 一般要保证两多项式在同一位置取值 即x_i相同
进行加法运算 直接依次将两点纵坐标相加 复杂度O(n)
进行乘法运算 只需将两点纵坐标相乘
复杂度也是O(n) 远好于系数表式的O(n^2)
已知点值 给出一个x值并求A(x)的过程叫插值
一般的 我们可以根据拉格朗日插值公式来进行计算 复杂度O(n^2)


<!-- part10 -->
那么现在我们步入正题 什么是快速傅里叶变换
首先我们要了解离散傅里叶变换(discrete fourier transform)
离散傅里叶变换是对于一个向量进行的变换
可以将这个向量看成一个n-1次多项式
并在每个单位根处求值 得出向量y 就是离散傅里叶变换后的结果
记为y=DFT_n(a) 也可以记为y=花体F(a)
直接使用霍纳法则求值的话 一次求值复杂度O(n)
求n个值的总复杂度就是O(n^2)
而快速傅里叶变换(Fast Fourier Transform)
是一种快速进行离散傅里叶变换的方法
它可以通过单位根的性质 将n次求值的复杂度降为O(nlog n)

<!-- part11 -->
首先对于这个n-1次多项式 它的系数向量为a
我们将其分为偶数项和奇数项两个向量 记为a^[0]和a^[1]
它们对应的两个多项式为A^[0]和A^[1]
现在将x代入 写出的A(x)的表达式是这样的
A^[0](x)和A^[1](x)的表达式是这样的
我们来想想办法把这三个表达式关联起来
把后两个表达式的自变量x换成x^2
我们会发现第二个表达式的项在第一个表达式中全部出现
而第三个表达式中的每一项都差了一个x
所以我们在它的前面乘以一个x
最后我们可以发现 A(x)=A^0(x^2)+xA^1(x^2)
这是我们就将原问题求A(x)在每个单位根上的值转化为
求次数界为n/2的两个多项式A^0(x)和A^1(x)在每个单位根平方上的值 再合并
我们代入两个具体单位根来看一看情况

<!-- part12 -->
根据我们之前提过的折半引理和消去引理 可以写出如下表达式
所以w_n^k方和w_n^{k+n/2}方均可以写成w_{n/2}^k
而A^0(x)和A^1(x)恰好均为次数界为n/2的多项式
所以问题又转化为了求
次数界为n/2的多项式A^0和A^1在各个n/2次单位根上的值
这两个问题和原问题的描述类似 只是原问题的次数界为n
所以 这两个问题是范围缩小一半的两个子问题
我们可以用同样方式求解这两个子问题（也就是递归解决）
再根据折半引理 就可以快速地合并结果
根据这个思想 我们可以写出运行时间T(n)的递归式
总的时间等于2倍的子问题时间加O(n)的合并时间
再根据主定理或者递归树 均可以推算出这个算法的时间复杂度为O(nlog n)
比代入公式求解的O(n^2)快了很多很多

<!-- part13 -->
了解了算法原理之后 我们来实现以下FFT算法
在本段视频内将以伪代码方式呈现
由于目前FFT是递归操作 所以我们要先设置递归边界
当输入向量的长度是1的时候 我们不需要处理
因为只有一个元素的向量FFT后的结果还是其本身
所以我们直接返回即可
如果没有到达边界 则需要将原向量按下标分成奇偶两个向量
再分别执行相同的FFT操作
注意次数界要除以二 也就相当于右移一位
在两个子问题解决完之后 我们要进行合并
根据之前推导的结论 可以发现
合并到第k组值的时候 需要主n次单位根的k次方来乘奇数项的值
我们通常将这个主n次单位根的k次方称为旋转因子
所以我们不妨设一个常量作为主n次单位根
再设一个变量来作为旋转因子
并且当k为0时其值为1 所以设w=1
然后执行主合并操作 一共n/2次
首先在这个循环末尾 我们每次要将旋转因子乘以w_n
来保证第k次执行的时候 w=w_n^k
然后根据前面推导过的公式 就可以执行合并了
这样 对一个数组执行FFT之后的结果就覆盖了原来的值 也节省了空间
但需要注意的一点是 输入的lim一定要保证是2的幂
而且a数组不能比lim小
这样就可以做到将a数组扩大到2的幂 并且补位的高次项系数为0 不干扰i结果

<!-- part14 -->
这里我将针对在算法竞赛中常用的C++语言来具体实现这个伪代码
首先我们要定义常数PI 也就是acos(-1)
复数模板在前面已经介绍过了 这里不再赘述
对于FFT函数 我们要传入两个参数 一个是复数数组a 另一个是次数界lim
当lim=1的时候 什么都不做 直接返回
其余情况 先对原数组进行分组
创建两个新复数数组 a0 a1
然后对下标的奇偶进行分类 写入这两个新数组中
之后对两个数组执行FFT 传入的次数界为lim的一半也就是右移一位
合并时先定义两个变量 一个是主n次单位根 另一个是旋转因子
进行循环 从0开始到小于lim的一半
根据公式或者伪代码 可以写出这一段
在循环的结尾 将旋转因子乘以主n次单位根
这样我们就实现了这个算法


<!-- part15 -->
现在我们来考虑一下如何能使这个算法更高效
首先 我们可以发现伪代码的第9、10行含有一个公共子表达式
由于复数乘法运算比较慢 所以不妨将其计算一次存在变量t中
在合并时用a0加t和减t 可以使运算更快一点
这样的一次操作 叫做 一次蝴蝶操作
然后 我们来考虑如何不使用递归 而是使用迭代来实现
我们可以观察一下每次递归传给FFT函数的a数组的内容
每次都把当前数组的奇数位和偶数位分开
最后得到的结果就是这样
我们如果能知道递归最终的顺序 并按照顺序重新排列
那么只需要合并就可以解决 不需要向下递归的时间
也节省了递归所需要的空间
现在我们假定可以实现数组的重新排列
来考虑一下如何实现合并
先来标记一下合并的层数
根据前面 我们知道每次合并时都需要一个旋转因子
而通过观察 我们可以发现 
每次合并时需要的主n次单位根的n取决于合并后的数组有多少个元素
而有多少个元素有可以根据当前合并的层数来确定
现在我们来尝试实现这个算法的伪代码
先对原数组重新排列
再用一个循环来确定当前合并的层数 从1到次数界的对数
然后定义两个常量 表示合并后序列的长度m 和主m次单位根
再用一个循环对每隔m的一组执行蝴蝶操作
定义一个变量作为旋转因子
然后再用一个循环对每组内对应的数进行操作
和之前同理 在循环的结尾要对旋转因子进行更新
剩下的就是蝴蝶操作了

<!-- part16 -->
现在再来思考一下如何求出需要的顺序 这个操作被称为位逆序置换
先分析一下最后下标的规律
将下标分离出来 再化为二进制
不难发现 需要的下标的二进制和当前位置的二进制恰好互为倒序
所以这个操作被称为位逆序置换
执行位逆序置换 我们可以用nlogn的复杂度直接模拟
但效率不是很高 我们也可以在O(n)的复杂度内实现预处理
还是来探究一下位逆序置换的规律
第一个规律 不难发现偶数位上的二进制数首位为0
奇数位上的二进制数首位为1
第二个规律也不难发现 每两个二进制数除了首位之外的每一位都相同
那么这些相同的位有有什么规律呢
进一步观察可以发现 它们是上一级子问题的解
也就是只含2位的二进制数的位逆序置换
有了这个经验我们也可以发现第四个规律
前一半结果的二进制数除最后一位外也是上一级子问题的解
所以我们可以写出一个递推公式来推出第i位上需要的下标
先找到子问题的解 也就是i/2位置上的二进制数右移一位
即 取它的前n-1位
然后确定首位是0还是1
将i和1做按位与运算 若i是奇数则结果为1 反之为0
在左移总位数-1位将其移动到首位
将两部分做按位或运算 就可以将首位和其他位合并在一起
这样在O(n)时间内就能完成对最终顺序的预处理

根据这个算法流程 我们可以画出这样一个图
输入一个数组a 先对它进行位逆序置换操作
然后每层每组执行蝴蝶操作
最后输出结果数组y


<!-- part17 -->
在实现这个算法时 首先需要预处理出一个rev数组
设n表示a数组的原长度
定义一个变量lim表示次数界
将lim从1左移至大于n 并记录下左移的次数 也就是二进制数的位数
根据前面推导的递推式 可以预处理出rev数组
在FFT函数的开始 需要按照rev中的编号对a数组排序
排序后根据前面的伪代码 就可以一点一点完成这个函数了


<!-- part18 -->
现在我们再来讨论一下快速傅里叶变换逆变换
--2x
FFT求的离散傅里叶变换的公式是这样
我们可以把它写成矩阵与向量相乘的形式
其中的Vn是一个范德蒙德矩阵
它的第i行第j列的元素为主n次单位根的ij次方
离散傅里叶变换给出a求y 而离散傅里叶逆变换给出y求a
所以要用Vn的逆矩阵乘向量y
这里给出 Vn的逆矩阵的第i行第j列元素为n分之主n次单位根的-ij次方
我们可以用Vn与这个矩阵相乘来验证结论
将这两个矩阵相乘 对第i行第j列的元素进行化简
根据最后的结果和前面所说的求和引理可以发现
只有当i=j也就是处于对角线上时 这个值为1
其余情况下全为0 所以结果是一个单位矩阵
所以我们给出的矩阵确实是Vn的逆矩阵
我们再将这个逆矩阵代入
再进行化简 提出分母的n
我们可以发现 逆变换的公式和傅里叶变换的公式十分类似
除了逆变换结果需要乘以1/n之外 逆变换中是主n次单位根的-i次方
所以我们可以使用和傅里叶变换的同样方法
仅仅将程序中的主n次单位根改为主n次单位根的-1次方
就可以使用相同的程序解决了
2x--

<!-- part19 -->
根据前面快速傅里叶逆变换的思想
可以仅仅在FFT的代码基础上稍作更改 来同时实现两个变换
由于两个变换不同的地方仅仅是主n次单位根虚部的正负
所以可以向FFT函数中传入一个参数来确定是哪一个变换
在定义主n次单位根时 用opt乘虚部
此时 若opt为1则表示为离散傅里叶变换 若opt为-1则表示为逆变换
在函数的结尾 我们还需要判断一下opt是否为-1
若是-1 则还需要将每个元素除以元素个数 也就是lim


<!-- part20 -->
最后我们来实现FFT在算法竞赛中最常见的应用
也就是求多项式乘积 即两向量的卷积
求两个向量的卷积 可以用O(nlogn)的时间求出两个向量的离散傅里叶变换
即将系数表式转化为点值表示
然后 在O(n)时间内对两个结果逐元素相乘 也就是点值表示中的乘法
最后再用O(nlogn)的时间求出乘法结果的逆傅里叶变换
也就是将点值表示转化为系数表式
这样就可以在O(nlogn)的时间复杂度内算出卷积
其中需要注意 两个向量的长度需要统一到同一2的幂
并且输入时的长度应扩大1倍 否则不足以进行最后的逆变换
在实现时 我们同时完成这两个目标 直接将lim左移至大于两数组的长度和
先输入两个多项式的次数n和m
然后输入各项系数 将他们存在F和G数组的实部中
再预处理出lim和rev数组
分别对F和G进行快速傅里叶变换
再逐项相乘 保存在F数组中
再对F数组进行快速傅里叶逆变换
就可以得到最后的卷积了


<!-- part21 -->
那么这就是这一期视频的全部内容了
这一期视频中 我们学习了快速傅里叶变换的原理和具体的代码实现
并了解了快速傅里叶逆变换的原理 并进行了简单的卷积运算
感谢您观看到这里 希望您能在评论区里给出反馈
制作这一期视频非常不易 点击三连支持一下up主吧
想看到更多关于算法的讲解呢 不妨点一下关注
那么我们下一期再见
